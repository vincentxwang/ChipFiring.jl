var documenterSearchIndex = {"docs":
[{"location":"api/#ChipFiring","page":"Reference","title":"ChipFiring","text":"","category":"section"},{"location":"api/","page":"Reference","title":"Reference","text":"Documentation for ChipFiring.","category":"page"},{"location":"api/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"api/#ChipFiring.ChipFiringGraph","page":"Reference","title":"ChipFiring.ChipFiringGraph","text":"ChipFiringGraph\n\nA structure to represent the underlying (multi)graph of a chip-firing graph. A graph is assumed to  be undirected, connected, and with no self-loops.\n\nFields\n\nadj_matrix::Matrix{Int}: The n x n multiplicity matrix, where adj_matrix[i, j] is the number of edges between vertex i and vertex j.\nnum_vertices::Int: The number of vertices in the graph.\nnum_edges::Int: The total number of edges in the graph.\nadj_list::Vector{Vector{Int}}: An adjacency list where adj_list[i] contains the neighbors of vertex i. This represents the underlying simple graph, meaning each neighbor appears only once, regardless of edge multiplicity.\nedge_list::Vector{Tuple{Int, Int}}: A vector of tuples, where each tuple (i, j) represents an edge. Edges are included with their full multiplicity.\nvalency_list::Vector{Int}: A vector where valency_list[i] stores the degree of vertex i, accounting for edge multiplicity.\n\nConstructors\n\nChipFiringGraph(multiplicity_matrix::Matrix{Int}): Constructs a ChipFiringGraph from a square, symmetric multiplicity matrix. Throws an error if the matrix is not square, not symmetric, or if the graph is not connected.\nChipFiringGraph(num_vertices::Int, edge_list::Vector{Tuple{Int, Int}}): Constructs a ChipFiringGraph from a list of edges and the total number of vertices.\n\n\n\n\n\n","category":"type"},{"location":"api/#ChipFiring.Divisor","page":"Reference","title":"ChipFiring.Divisor","text":"Divisor <: AbstractVector{Int}\n\nA struct representing a divisor (i.e., chip configuration) on a graph.\n\nFields\n\nchips::Vector{Int}: An n-element vector where chips[i] is the number of chips on vertex i.\n\n\n\n\n\n","category":"type"},{"location":"api/#ChipFiring.Workspace","page":"Reference","title":"ChipFiring.Workspace","text":"Workspace\n\nA mutable container for pre-allocated arrays and temporary data structures used in performance-critical algorithms.\n\nThis struct is exposed for users who need to run many computations in a tight loop and want to avoid repeated memory allocations. For one-off calculations, it is often more convenient to use the wrapper functions (e.g., q_reduced(g, d, q)) which handle workspace creation automatically.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.show-Tuple{IO, ChipFiringGraph}","page":"Reference","title":"Base.show","text":"Base.show(io::IO, g::ChipFiringGraph)\n\nDefines the text representation of a ChipFiringGraph.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.borrow!-Tuple{ChipFiringGraph, Divisor, Int64}","page":"Reference","title":"ChipFiring.borrow!","text":"borrow!(G::ChipFiringGraph, D::Divisor, v::Int)\n\nBorrows from a single vertex v.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.borrow!-Tuple{ChipFiringGraph, Divisor, Vector{Int64}}","page":"Reference","title":"ChipFiring.borrow!","text":"borrow!(G::ChipFiringGraph, D::Divisor, vertices::Vector{Int})\n\nBorrows from each vertex in the provided vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.clear!-Tuple{Workspace}","page":"Reference","title":"ChipFiring.clear!","text":"clear!(ws::Workspace)\n\nResets all fields in the Workspace to their empty and default states.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.compute_genus-Tuple{ChipFiringGraph}","page":"Reference","title":"ChipFiring.compute_genus","text":"compute_genus(G::ChipFiringGraph) -> Int\n\nComputes the genus g (in the topological sense) of the graph represented by G, which is given by\n\ng = E - V + 1\n\nNote this definition is from divisor theory and differs from typical definitions of genus on a graph.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.compute_gonality-Tuple{ChipFiringGraph}","page":"Reference","title":"ChipFiring.compute_gonality","text":"compute_gonality(G::ChipFiringGraph; min_d=1, max_d=nothing, verbose=false, r=1) -> Int\n\nComputes the r-th (default: 1) gonality of a graph G.\n\nArguments\n\nG::ChipFiringGraph: The graph to analyze.\n\nOptional Arguments\n\nmin_d=1: The minimum degree to check.\nmax_d=nothing: The maximum degree to check. Defaults to nothing.\nverbose=false:  If true, prints progress updates.\nr=1: Calculates r-th gonality. Defaults to 1.\n\nReturns\n\nInt: The computed gonality of the graph. Returns -1 if not found within max_d.\n\nNote: The result of compute_gonalitymay returnr \\cdot nin the case whenmax_dis set tor \\cdot n - 1`.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.dhar!-Tuple{ChipFiringGraph, Divisor, Int64, Workspace}","page":"Reference","title":"ChipFiring.dhar!","text":"dhar!(G::ChipFiringGraph, D::Divisor, q::Int, ws::Workspace) -> Bool\n\nPerforms a burn starting from a source vertex q to determine if the divisor D is super-stable with respect to q.\n\nArguments\n\nG::ChipFiringGraph: The graph structure.\nD::Divisor: Input divisor.\nq::Int: The vertex (1-indexed) from which to start the burn.\nws::Workspace: The following fields are read from ws: ws.burned, ws.legals, ws.threats\n\nReturns\n\nis_superstable::Bool: true if the entire graph was burned.\n\nModifies\n\nws.burned: Tracks burned vertices.\nws.legals: The indices of unburned vertices that form a legal firing.\nws.threats: Tracks threats to unburned vertices.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.dhar-Tuple{ChipFiringGraph, Divisor, Int64}","page":"Reference","title":"ChipFiring.dhar","text":"dhar(G::ChipFiringGraph, D::Divisor, q::Int) -> Tuple{Bool, Vector{Int}}\n\nPerforms a burn starting from a source vertex q to determine if the divisor D is super-stable with respect to q.\n\nArguments\n\nG::ChipFiringGraph: The graph structure.\nD::Divisor: The chip configuration to test.\nq::Int: The vertex (1-indexed) from which to start the burn.\n\nReturns\n\nThe first element is true if the divisor is super-stable, false otherwise.\nThe second element is a vector of unburned vertices. This vector is empty if the divisor is super-stable.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.divisor_rank-Tuple{ChipFiringGraph, Divisor}","page":"Reference","title":"ChipFiring.divisor_rank","text":"divisor_rank(G::ChipFiringGraph, D::Divisor) -> Int\n\nReturns the rank (in the sense of Baker and Norine) of a divisor D. See Divisors and Sandpiles by Corry and Perkinson. This is a convenience wrapper.\n\nArguments\n\nG::ChipFiringGraph: The graph to analyze.\nD::Divisor: The divisor whose rank is to be computed.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.find_negative_vertices!-Tuple{Vector{Int64}, ChipFiringGraph, Divisor, Int64}","page":"Reference","title":"ChipFiring.find_negative_vertices!","text":"find_negative_vertices!(out_vec::Vector{Int}, G::ChipFiringGraph, D::Divisor, q::Int)\n\nFinds all vertices with negative chips (excluding the sink q) and pushes them into the pre-allocated out_vec. This is a non-allocating operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.get_num_edges-Tuple{ChipFiringGraph, Int64, Int64}","page":"Reference","title":"ChipFiring.get_num_edges","text":"get_num_edges(G::ChipFiringGraph, u::Int, v::Int) -> Int\n\nReturns the number of edges (multiplicity) between two vertices u and v.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.has_rank_at_least_r!-Tuple{ChipFiringGraph, Int64, Workspace}","page":"Reference","title":"ChipFiring.has_rank_at_least_r!","text":"has_rank_at_least_r!(G::ChipFiringGraph, r::Int, ws::Workspace) -> Bool\n\nChecks if a divisor ws.d1 has rank at least r.\n\nArguments\n\nG::ChipFiringGraph: The graph structure.\nr::Int: The minimum rank to check for.\nws::Workspace: Workspace containing the divisor in ws.d1.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.has_rank_at_least_r-Tuple{ChipFiringGraph, Divisor, Int64}","page":"Reference","title":"ChipFiring.has_rank_at_least_r","text":"has_rank_at_least_r(G::ChipFiringGraph, D::Divisor, r::Int) -> Bool\n\nChecks if a divisor D has rank at least r.\n\nArguments\n\nG::ChipFiringGraph: The graph to analyze.\nD::Divisor: The divisor to check.\nr::Int: The minimum rank to check for.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.is_effective-Tuple{Divisor}","page":"Reference","title":"ChipFiring.is_effective","text":"is_effective(D::Divisor) -> Bool\n\nChecks if a divisor D is effective, meaning all its chip counts are non-negative.\n\nArguments\n\nD::Divisor: The divisor to check.\n\nReturns\n\nBool: true if D(v) geq 0 for all vertices v, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.is_equivalent-Tuple{ChipFiringGraph, Divisor, Divisor}","page":"Reference","title":"ChipFiring.is_equivalent","text":"is_equivalent(G::ChipFiringGraph, D1::Divisor, D2::Divisor) -> Bool\n\nTests if two divisors are equivalent under chip-firing.\n\nArguments\n\nG::ChipFiringGraph: The graph to analyze.\nD1::Divisor: The first divisor.\nD2::Divisor: The second divisor.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.is_winnable!-Tuple{ChipFiringGraph, Divisor, Workspace}","page":"Reference","title":"ChipFiring.is_winnable!","text":"is_winnable!(G::ChipFiringGraph, D::Divisor, ws::Workspace) -> Bool\n\nChecks if a divisor D is linearly equivalent to an effective divisor using a version of Dhar's burning algorithm.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.is_winnable-Tuple{ChipFiringGraph, Divisor}","page":"Reference","title":"ChipFiring.is_winnable","text":"is_winnable(G::ChipFiringGraph, D::Divisor) -> Bool\n\nChecks if a divisor D is linearly equivalent to an effective divisor using a version of Dhar's burning algorithm.\n\nThis is a convenience wrapper that allocates a temporary workspace. For performance-critical code where this function is called repeatedly, use the version that accepts a  Workspace argument.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.laplacian-Tuple{ChipFiringGraph}","page":"Reference","title":"ChipFiring.laplacian","text":"laplacian(G::ChipFiringGraph) -> Matrix{Int}\n\nReturns the discrete Laplacian matrix of G.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.lend!-Tuple{ChipFiringGraph, Divisor, Int64}","page":"Reference","title":"ChipFiring.lend!","text":"lend!(G::ChipFiringGraph, D::Divisor, v::Int)\n\nLends (fires) a single vertex v.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.lend!-Tuple{ChipFiringGraph, Divisor, Vector{Int64}}","page":"Reference","title":"ChipFiring.lend!","text":"lend!(G::ChipFiringGraph, D::Divisor, vertices::Vector{Int})\n\nLends (fires) from each vertex in the provided vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.neighbors-Tuple{ChipFiringGraph, Int64}","page":"Reference","title":"ChipFiring.neighbors","text":"neighbors(G::ChipFiringGraph, v::Int) -> Vector{Int}\n\nReturns a vector containing the indices of the neighbors of vertex v.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.next_composition!-Tuple{Vector{Int64}}","page":"Reference","title":"ChipFiring.next_composition!","text":"next_composition!(v::Vector{Int}) -> Bool\n\nMutates a vector v into the next composition of the integer sum(v), generating them in colexicographical order.\n\nAlgorithm\n\nFind the first non-zero element from the left, v[t]. This is the \"pivot\".\nIf no such element exists (or it's the last one), we are at the end of the sequence.\nMove one unit from the pivot to its right neighbor: v[t+1] += 1.\nMove the remaining value of the pivot (v[t] - 1) to the very first position v[1].\nSet the pivot's original position v[t] to zero.\n\nExample: [3, 0, 0] -> [2, 1, 0] -> [1, 2, 0] -> [0, 3, 0] -> [2, 0, 1] ...\n\nReturns\n\ntrue if a next configuration was generated.\nfalse if v was already the last configuration (e.g., [0, 0, ..., d]).\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.parse_graph6-Tuple{String}","page":"Reference","title":"ChipFiring.parse_graph6","text":"parse_graph6(g6_string::String) -> ChipFiringGraph\n\nParses a graph from a string in the graph6 format and returns a ChipFiringGraph.\n\nThis function fully implements the graph6 specification for simple, undirected graphs, including the 1, 4, and 8-byte encodings for the number of vertices.\n\nArguments\n\ng6_string::String: The string representing the graph. An optional header >>graph6<< is ignored if present.\n\nReturns\n\nA ChipFiringGraph object.\n\nThrows\n\nArgumentError: If the string is malformed, contains invalid characters, or ends unexpectedly.\n\nWARNING:\n\nThe backslash `` is a valid character in the graph6 format, but needs to be escaped in Julia.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.q_reduced!-Tuple{ChipFiringGraph, Divisor, Int64, Workspace}","page":"Reference","title":"ChipFiring.q_reduced!","text":"q_reduced!(G::ChipFiringGraph, D::Divisor, q::Int, ws::Workspace) -> Divisor\n\nFinds the equivalent q-reduced effective divisor to D.\n\nArguments\n\nG::ChipFiringGraph: The graph structure.\nD::Divisor: The initial chip configuration.\nq::Int: The sink vertex.\nws::Workspace: The workspace containing pre-allocated arrays.\n\nReturns\n\nd::Divisor: The resulting divisor\n\nModifies\n\nws.d2: Uses this space to construct the resulting divisor\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.q_reduced-Tuple{ChipFiringGraph, Divisor, Int64}","page":"Reference","title":"ChipFiring.q_reduced","text":"q_reduced(G::ChipFiringGraph, D::Divisor, q::Int) -> Divisor\n\nFinds the equivalent q-reduced effective divisor to D.\n\nThis is a convenience wrapper that allocates a temporary workspace. For performance-critical code where this function is called repeatedly, use the version that accepts a  Workspace argument.\n\nArguments\n\nG::ChipFiringGraph: The graph structure.\nD::Divisor: The initial chip configuration.\nq::Int: The sink vertex.\n\nReturns\n\nd::Divisor: The resulting divisor\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.subdivide-Tuple{ChipFiringGraph, Int64}","page":"Reference","title":"ChipFiring.subdivide","text":"subdivide(G::ChipFiringGraph, k::Int) -> ChipFiringGraph\n\nGiven a ChipFiringGraph G, produces another ChipFiringGraph which is an k-uniform subdivision of G.\n\nArguments\n\nG::ChipFiringGraph: The original graph\nk::Int: Number of uniform subdivisions (e.g., 1 returns original graph, 2 produces 2-uniform subdivision)\n\nReturns\n\nA k-uniform subdivided ChipFiringGraph\n\n\n\n\n\n","category":"method"},{"location":"bg/#Background-and-conventions","page":"Background and conventions","title":"Background and conventions","text":"","category":"section"},{"location":"bg/","page":"Background and conventions","title":"Background and conventions","text":"We take a graph to be with multi-edges, connected, and no self-loops. We label the vertices 1 dots n. The valence of a vertex v is the number of edges incident to v.","category":"page"},{"location":"bg/","page":"Background and conventions","title":"Background and conventions","text":"A ChipFiringGraph encodes the graph structure. It can be constructed through either a multiplicity matrix or an edge list.","category":"page"},{"location":"bg/","page":"Background and conventions","title":"Background and conventions","text":"For example:","category":"page"},{"location":"bg/","page":"Background and conventions","title":"Background and conventions","text":"julia> multiplicity_matrix = [\n    0 2 0 1;\n    2 0 1 0;\n    0 1 0 1;\n    1 0 1 0   \n]\n[output omitted]\n\njulia> edge_list = [(1,2), (1,2), (1,4), (2,3), (3,4)]\n[output omitted]\n\n# Constructor: multiplicity matrix\njulia> g = ChipFiringGraph(multiplicity_matrix)\nGraph(V=4, E=5, Edges=[(1, 2), (1, 2), (1, 4), (2, 3), (3, 4)])\n\n# Constructor: number of vertices and edge list\njulia> g = ChipFiringGraph(4, edge_list)","category":"page"},{"location":"bg/","page":"Background and conventions","title":"Background and conventions","text":"A Divisor encodes a divisor on a graph. However, it is a distinct object from a ChipFiringGraph  and for all practical purposes, it will act like a vector, where the i-th index corresponds to the number of chips on vertex i.","category":"page"},{"location":"bg/","page":"Background and conventions","title":"Background and conventions","text":"julia> d = Divisor([1, 2, 3, -1])\n4-element Divisor:\n  1\n  2\n  3\n -1","category":"page"},{"location":"#ChipFiring.jl","page":"Home","title":"ChipFiring.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ChipFiring.jl is a Julia package for analyzing chip-firing games on graphs. The codes are roughly based on the algorithms given in Sandpiles and Divisors: An Introduction to Chip-Firing by Corry and Perkinson (2018). A key objective is for the package to be useful for both researchers and students. The package is built around a two-tier API design: a simple layer for interactive use, and a high-performance layer for intensive computations. Its features include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Basic operations on chip-firing graphs (e.g. firing, lending)\nComputations of r-th graph gonality\nUniform subdivisions of graphs\nRank computations\nq-reduction, Dhar's burning algorithm, and equivalence\nConversion from graph6 format","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have not installed Julia, please follow the instructions here. ChipFiring.jl works with Julia v1.10 and newer, but the latest stable release is recommended.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ChipFiring.jl is a registered Julia package. The following commands in the Julia REPL will install ChipFiring.jl. You may copy and paste these commands into REPL including the leading julia> prompts â€“ they will automatically be trimmed by Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\n\njulia> Pkg.add(\"ChipFiring\")","category":"page"},{"location":"#A-short-example","page":"Home","title":"A short example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package must first be loaded.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using ChipFiring","category":"page"},{"location":"","page":"Home","title":"Home","text":"Below, we calcuate the gonality of a graph, as well as q-reduce a divisor on the graph.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> multiplicity_matrix = [\n    0 2 0 1;\n    2 0 1 0;\n    0 1 0 1;\n    1 0 1 0   \n]\n[output omitted]\n\njulia> g = ChipFiringGraph(multiplicity_matrix)\nGraph(V=4, E=5, Edges=[(1, 2), (1, 2), (1, 4), (2, 3), (3, 4)])\n\njulia> compute_gonality(g)\n2\n\njulia> d = Divisor([1, 1, 1, 1])\nDivisor([1, 1, 1, 1])\n\njulia> q_reduced(g, d, 1)\nDivisor([-4, 1, 1, 0])","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package was developed during the SMALL 2025 REU hosted at Williams College, funded by NSF Grant DMS2241623. Special thanks to Charlotte Chen, Benham Cobb, Ralph Morrison, Noam Pasman, Madeline Reeve, for contributing code and/or feedback.","category":"page"}]
}
