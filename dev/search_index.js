var documenterSearchIndex = {"docs":
[{"location":"api/#ChipFiring","page":"Reference","title":"ChipFiring","text":"","category":"section"},{"location":"api/","page":"Reference","title":"Reference","text":"Documentation for ChipFiring.","category":"page"},{"location":"api/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"api/#ChipFiring.ChipFiringGraph","page":"Reference","title":"ChipFiring.ChipFiringGraph","text":"ChipFiringGraph\n\nA structure to represent the underlying graph of a chip-firing graph.\n\nThis struct provides multiple representations of the graph's structure to suit different computational needs. It is designed for undirected, connected graphs, and the input multiplicity matrix is expected to be symmetric.\n\nFields\n\nadj_matrix::Matrix{Int}: The n x n multiplicity matrix, where adj_matrix[i, j] is the number of edges between vertex i and vertex j.\nnum_vertices::Int: The number of vertices in the graph, n.\nnum_edges::Int: The total number of edges in the graph.\nadj_list::Vector{Vector{Int}}: An adjacency list where adj_list[i] contains the neighbors of vertex i. This represents the underlying simple graph, meaning each neighbor appears only once, regardless of edge multiplicity.\nedge_list::Vector{Tuple{Int, Int}}: A vector of tuples, where each tuple (i, j) represents an edge. Edges are included with their full multiplicity.\ndegree_list::Vector{Int}: A vector where degree_list[i] stores the degree of vertex i, accounting for edge multiplicity.\n\nConstructors\n\nChipFiringGraph(multiplicity_matrix::Matrix{Int}): Constructs a ChipFiringGraph from a square, symmetric multiplicity matrix. Throws an error if the matrix is not square, not symmetric, or if the graph is not connected.\nChipFiringGraph(num_vertices::Int, edge_list::Vector{Tuple{Int, Int}}): Constructs a ChipFiringGraph from a list of edges and the total number of vertices.\n\n\n\n\n\n","category":"type"},{"location":"api/#ChipFiring.Divisor","page":"Reference","title":"ChipFiring.Divisor","text":"Divisor\n\nA struct representing a chip configuration (or \"divisor\") on a graph.\n\nFields\n\nchips::Vector{Int}: An n-element vector where chips[i] is the number of chips on vertex i.\n\n\n\n\n\n","category":"type"},{"location":"api/#ChipFiring.Workspace","page":"Reference","title":"ChipFiring.Workspace","text":"Workspace\n\nA struct that designates space for memory allocations for optimization. This should never  be necessary to be called by front-facing access points, although it is possible that it may be useful in some performance-sensitive cases.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.show-Tuple{IO, ChipFiringGraph}","page":"Reference","title":"Base.show","text":"show(io::IO, g::ChipFiringGraph)\n\nProvides a concise, single-line string representation of a ChipFiringGraph.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.borrow!-Tuple{ChipFiringGraph, Divisor, Int64}","page":"Reference","title":"ChipFiring.borrow!","text":"borrow!(g::ChipFiringGraph, d::Divisor, v::Int)\n\nBorrows from a single vertex v.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.borrow!-Tuple{ChipFiringGraph, Divisor, Vector{Int64}}","page":"Reference","title":"ChipFiring.borrow!","text":"borrow!(g::ChipFiringGraph, d::Divisor, vertices::Vector{Int})\n\nBorrows from each vertex in the provided vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.compute_genus-Tuple{ChipFiringGraph}","page":"Reference","title":"ChipFiring.compute_genus","text":"compute_genus(g::ChipFiringGraph) -> Int\n\nReturns the genus (in the topological sense) of the graph represented by g. Note that this is  not the typical definition of graph genus.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.compute_gonality-Tuple{ChipFiringGraph}","page":"Reference","title":"ChipFiring.compute_gonality","text":"compute_gonality(g::ChipFiringGraph; min_d=1, max_d=nothing, verbose=false, r=1, cgon=false) -> Int\n\nComputes the r-th (default: 1) gonality of a graph g.\n\nArguments\n\ng::ChipFiringGraph: The graph to analyze.\n\nOptional Arguments\n\nmin_d=1: The minimum degree d to check.\nmax_d=nothing: The maximum degree d to check. Defaults to nothing.\nverbose=false:  If true, prints progress updates.\nr=1: Calculates r-th gonality. Defaults to 1.\ncgon=false: Calculate the concentrated r-th gonality if true. \n\nReturns\n\nInt: The computed gonality of the graph. Returns -1 if not found within max_d.\n\nThe result of computegonality may return r * n in the case when maxd is set to r * n - 1.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.dhar!-Tuple{ChipFiringGraph, Divisor, Int64, Workspace}","page":"Reference","title":"ChipFiring.dhar!","text":"dhar!(g::ChipFiringGraph, divisor::Divisor, source::Int, ws::Workspace) -> Bool\n\nPerforms a recursive burn starting from a source vertex to determine if a divisor is super-stable with respect to that source.\n\nFollowing the user's definition, a divisor is super-stable if the entire graph burns. A vertex v \"burns\" if its number of chips is less than the number of edges connecting it to already-burnt vertices.\n\nArguments\n\ng::ChipFiringGraph: The graph structure.\ndivisor::Divisor: Input divisor.\nsource::Int: The vertex (1-indexed) from which to start the burn.\n\nReturns\n\nis_superstable::Bool: true if the entire graph was burned.\n\nModifies\n\nws.burned::Vector{Bool}: Tracks burned vertices. \nws.legals::Vector{Int}: The indices of unburned vertices that form a legal firing.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.dhar-Tuple{ChipFiringGraph, Divisor, Int64}","page":"Reference","title":"ChipFiring.dhar","text":"dhar(g::ChipFiringGraph, divisor::Divisor, source::Int) -> Tuple{Bool, Vector{Int}}\n\nPerforms a burn starting from a source vertex to determine if a divisor is super-stable.\n\nThis is a convenience wrapper that allocates a temporary workspace. For performance-critical code where this function is called repeatedly, use the version that accepts a  Workspace argument.\n\nArguments\n\ng::ChipFiringGraph: The graph structure.\ndivisor::Divisor: The chip configuration to test.\nsource::Int: The vertex (1-indexed) from which to start the burn.\n\nReturns\n\nThe first element is true if the divisor is super-stable, false otherwise.\nThe second element is a vector of unburned vertices. This vector is empty if the divisor is super-stable.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.find_negative_vertices!-Tuple{Vector{Int64}, ChipFiringGraph, Divisor, Int64}","page":"Reference","title":"ChipFiring.find_negative_vertices!","text":"find_negative_vertices!(out_vec::Vector{Int}, g::ChipFiringGraph, d::Divisor, q::Int)\n\nFinds all vertices with negative chips (excluding the sink q) and pushes them into the pre-allocated out_vec. This is a non-allocating operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.get_num_edges-Tuple{ChipFiringGraph, Int64, Int64}","page":"Reference","title":"ChipFiring.get_num_edges","text":"get_num_edges(g::ChipFiringGraph, u::Int, v::Int) -> Int\n\nReturns the number of edges (multiplicity) between two vertices u and v.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.has_rank_at_least_r-Tuple{ChipFiringGraph, Divisor, Int64}","page":"Reference","title":"ChipFiring.has_rank_at_least_r","text":"has_rank_at_least_r(g::ChipFiringGraph, d::Divisor, r::Int, cgon::Bool) -> Bool\n\nGiven a ChipFiringGraph g and Divisor d, returns a boolean determining whether or not d has rank at least r. \n\nSet cgon to be true if we are interested in concentrated rank. \n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.has_rank_at_least_r-Tuple{ChipFiringGraph, Int64, Bool, Workspace}","page":"Reference","title":"ChipFiring.has_rank_at_least_r","text":"has_rank_at_least_r(g::ChipFiringGraph, r::Int, cgon::Bool, ws::Workspace) -> Bool\n\nChecks if a divisor ws.d1 has rank at least r.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.is_winnable-Tuple{ChipFiringGraph, Divisor, Workspace}","page":"Reference","title":"ChipFiring.is_winnable","text":"is_winnable(g::ChipFiringGraph, divisor::Divisor, ws::Workspace) -> Bool\n\nChecks if a chip configuration is linearly equivalent to an effective divisor using a version of Dhar's burning algorithm.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.is_winnable-Tuple{ChipFiringGraph, Divisor}","page":"Reference","title":"ChipFiring.is_winnable","text":"is_winnable(g::ChipFiringGraph, divisor::Divisor) -> Bool\n\nChecks if a chip configuration is linearly equivalent to an effective divisor using a version of Dhar's burning algorithm.\n\nThis is a convenience wrapper that allocates a temporary workspace. For performance-critical code where this function is called repeatedly, use the version that accepts a  Workspace argument.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.laplacian-Tuple{ChipFiringGraph}","page":"Reference","title":"ChipFiring.laplacian","text":"laplacian(g::ChipFiringGraph) -> Matrix{Int}\n\nReturns the discrete Laplacian matrix of g.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.lend!-Tuple{ChipFiringGraph, Divisor, Int64}","page":"Reference","title":"ChipFiring.lend!","text":"lend!(g::ChipFiringGraph, d::Divisor, v::Int)\n\nLends (fires) a single vertex v.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.lend!-Tuple{ChipFiringGraph, Divisor, Vector{Int64}}","page":"Reference","title":"ChipFiring.lend!","text":"lend!(g::ChipFiringGraph, d::Divisor, vertices::Vector{Int})\n\nLends (fires) from each vertex in the provided vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.neighbors-Tuple{ChipFiringGraph, Int64}","page":"Reference","title":"ChipFiring.neighbors","text":"neighbors(g::ChipFiringGraph, v::Int) -> Vector{Int}\n\nReturns a vector containing the indices of the neighbors of vertex v.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.next_composition!-Tuple{Vector{Int64}}","page":"Reference","title":"ChipFiring.next_composition!","text":"next_composition!(v::Vector{Int}) -> Bool\n\nMutates the vector v into the next composition in-place. Assumes the sum of elements should remain constant.\n\nReturns\n\ntrue if a next configuration was generated.\nfalse if v was already the last configuration (e.g., [0, 0, ..., d]).\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.q_reduced-Tuple{ChipFiringGraph, Divisor, Int64, Workspace}","page":"Reference","title":"ChipFiring.q_reduced","text":"q_reduced(g::ChipFiringGraph, divisor::Divisor; q::Int, ws::Workspace) -> Divisor\n\nFinds the equivalent, q-reduced effective divisor to the one given.\n\nArguments\n\ng: The graph structure.\ndivisor: The initial chip configuration.\nq: The sink vertex.\nws: The workspace containing pre-allocated arrays.\n\nReturns\n\nd::Divisor: The resulting divisor\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.q_reduced-Tuple{ChipFiringGraph, Divisor, Int64}","page":"Reference","title":"ChipFiring.q_reduced","text":"q_reduced(g::ChipFiringGraph, divisor::Divisor; q::Int, ws::Workspace) -> Divisor\n\nFinds the equivalent, q-reduced effective divisor to the one given, based on the algorithm from the user-provided Python code.\n\nThis is a convenience wrapper that allocates a temporary workspace. For performance-critical code where this function is called repeatedly, use the version that accepts a  Workspace argument.\n\nArguments\n\ng: The graph structure.\ndivisor: The initial chip configuration.\nq: The sink vertex.\nws: The workspace containing pre-allocated arrays.\n\nReturns\n\nd::Divisor: The resulting divisor\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.rank-Tuple{ChipFiringGraph, Divisor}","page":"Reference","title":"ChipFiring.rank","text":"rank(g::ChipFiringGraph, d::Divisor) -> Int\n\nGiven a ChipFiringGraph g and Divisor d, returns the rank (in the sense of Baker and Norine) of d on g. See Divisors and Sandpiles by Corry and Perkinson.\n\nSet cgon to be true if we are interested in concentrated rank.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.sprint_graph-Tuple{ChipFiringGraph}","page":"Reference","title":"ChipFiring.sprint_graph","text":"sprint_graph(g::ChipFiringGraph) -> String\n\nReturns a single-line string representation of a ChipFiringGraph.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.subdivide-Tuple{ChipFiringGraph, Int64}","page":"Reference","title":"ChipFiring.subdivide","text":"subdivide(g::ChipFiringGraph, subdivisions::Int) -> ChipFiringGraph\n\nGiven a ChipFiringGraph g, produces another ChipFiringGraph which is an k-uniform subdivision of g.\n\nArguments\n\ng::ChipFiringGraph the original graph\nsubdivisions::Int number of uniform subdivisions (1 returns original graph, 2 produces 2-uniform subdivision, etc.)\n\nReturns\n\nA k-uniform subdivided graph\n\n\n\n\n\n","category":"method"},{"location":"bg/#Background","page":"Background and conventions","title":"Background","text":"","category":"section"},{"location":"bg/","page":"Background and conventions","title":"Background and conventions","text":"We take a graph to be with multi-edges, connected, and no self-loops.","category":"page"},{"location":"bg/","page":"Background and conventions","title":"Background and conventions","text":"Do note that Divisors should be explicitly constructed to the functions instead of passing a vector. For example, has_rank_at_least_r(g, Divisor([1, 0, 1, 0, 0, 1, 0, 1]), 1).","category":"page"},{"location":"#ChipFiring.jl","page":"Home","title":"ChipFiring.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package contains routines to quickly calculate graph gonality of chip-firing graphs. The codes are roughly based on the algorithms given in Sandpiles and Divisors: An Introduction to Chip-Firing by Corry and Perkinson (2018).","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently, this package supports the following:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Basic operations on chip-firing graphs (e.g. firing, lending)\nComputations of graph gonality\nSubdivisions of graphs\nRank computations\nq-reduction and Dhar's burning algorithm","category":"page"},{"location":"#A-short-example","page":"Home","title":"A short example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"julia> multiplicity_matrix = [\n    0 2 0 1;\n    2 0 1 0;\n    0 1 0 1;\n    1 0 1 0   \n]\n\njulia> g = ChipFiringGraph(multiplicity_matrix)\nGraph(V=4, E=5, Edges=[(1, 2), (1, 2), (1, 4), (2, 3), (3, 4)])\n\njulia> compute_gonality(g)\n2\n\njulia> d = Divisor([1, 1, 1, 1])\nDivisor([1, 1, 1, 1])\n\njulia> q_reduced(g, d, 1)\nDivisor([-4, 1, 1, 0])","category":"page"}]
}
