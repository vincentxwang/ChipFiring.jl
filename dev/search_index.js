var documenterSearchIndex = {"docs":
[{"location":"api/#ChipFiring","page":"Reference","title":"ChipFiring","text":"","category":"section"},{"location":"api/","page":"Reference","title":"Reference","text":"Documentation for ChipFiring.jl.","category":"page"},{"location":"api/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"api/#ChipFiring.ChipFiringGraph","page":"Reference","title":"ChipFiring.ChipFiringGraph","text":"ChipFiringGraph\n\nA structure to represent the underlying (multi)graph of a chip-firing graph. A graph is assumed to  be undirected, connected, and with no self-loops.\n\nFields\n\nadj_matrix::Matrix{Int}: The n x n multiplicity matrix, where adj_matrix[i, j] is the number of edges between vertex i and vertex j.\nnum_vertices::Int: The number of vertices in the graph.\nnum_edges::Int: The total number of edges in the graph.\nadj_list::Vector{Vector{Int}}: An adjacency list where adj_list[i] contains the neighbors of vertex i. This represents the underlying simple graph, meaning each neighbor appears only once, regardless of edge multiplicity.\nedge_list::Vector{Tuple{Int, Int}}: A vector of tuples, where each tuple (i, j) represents an edge. Edges are included with their full multiplicity.\nvalency_list::Vector{Int}: A vector where valency_list[i] stores the degree of vertex i, accounting for edge multiplicity.\n\nConstructors\n\nChipFiringGraph(multiplicity_matrix::Matrix{Int}): Constructs a ChipFiringGraph from a square, symmetric multiplicity matrix. Throws an error if the matrix is not square, not symmetric, or if the graph is not connected.\nChipFiringGraph(num_vertices::Int, edge_list::Vector{Tuple{Int, Int}}): Constructs a ChipFiringGraph from a list of edges and the total number of vertices.\n\n\n\n\n\n","category":"type"},{"location":"api/#ChipFiring.Divisor","page":"Reference","title":"ChipFiring.Divisor","text":"Divisor <: AbstractVector{Int}\n\nA struct representing a divisor (i.e., chip configuration) on a graph.\n\nFields\n\nchips::Vector{Int}: An n-element vector where chips[i] is the number of chips on vertex i.\n\n\n\n\n\n","category":"type"},{"location":"api/#ChipFiring.Workspace","page":"Reference","title":"ChipFiring.Workspace","text":"Workspace\n\nA mutable container for pre-allocated arrays and temporary data structures used in performance-critical algorithms.\n\nThis struct is exposed for users who need to run many computations in a tight loop and want to avoid repeated memory allocations. For one-off calculations, it is often more convenient to use the wrapper functions (e.g., q_reduced(g, d, q)) which handle workspace creation automatically.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.show-Tuple{IO, ChipFiringGraph}","page":"Reference","title":"Base.show","text":"Base.show(io::IO, g::ChipFiringGraph)\n\nDefines the text representation of a ChipFiringGraph.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.borrow!-Tuple{ChipFiringGraph, Divisor, Int64}","page":"Reference","title":"ChipFiring.borrow!","text":"borrow!(G::ChipFiringGraph, D::Divisor, v::Int)\n\nBorrows from a single vertex v.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.borrow!-Tuple{ChipFiringGraph, Divisor, Vector{Int64}}","page":"Reference","title":"ChipFiring.borrow!","text":"borrow!(G::ChipFiringGraph, D::Divisor, vertices::Vector{Int})\n\nBorrows from each vertex in the provided vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.clear!-Tuple{Workspace}","page":"Reference","title":"ChipFiring.clear!","text":"clear!(ws::Workspace)\n\nResets all fields in the Workspace to their empty and default states.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.compute_genus-Tuple{ChipFiringGraph}","page":"Reference","title":"ChipFiring.compute_genus","text":"compute_genus(G::ChipFiringGraph) -> Int\n\nComputes the genus g (in the topological sense) of the graph represented by G, which is given by\n\ng = E - V + 1\n\nNote this definition is from divisor theory and differs from typical definitions of genus on a graph.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.compute_gonality-Tuple{ChipFiringGraph}","page":"Reference","title":"ChipFiring.compute_gonality","text":"compute_gonality(G::ChipFiringGraph; min_d=1, max_d=nothing, verbose=false, r=1) -> Int\n\nComputes the r-th (default: 1) gonality of a graph G.\n\nArguments\n\nG::ChipFiringGraph: The graph to analyze.\n\nOptional Arguments\n\nmin_d=1: The minimum degree to check.\nmax_d=nothing: The maximum degree to check. Defaults to nothing.\nverbose=false:  If true, prints progress updates.\nr=1: Calculates r-th gonality. Defaults to 1.\n\nReturns\n\nInt: The computed gonality of the graph. Returns -1 if not found within max_d.\n\nNote: The result may be inaccurate if min_d is set above the gonality of a graph.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.dhar!-Tuple{ChipFiringGraph, Divisor, Int64, Workspace}","page":"Reference","title":"ChipFiring.dhar!","text":"dhar!(G::ChipFiringGraph, D::Divisor, q::Int, ws::Workspace) -> Bool\n\nPerforms a burn starting from a source vertex q to determine if the divisor D is super-stable with respect to q.\n\nArguments\n\nG::ChipFiringGraph: The graph structure.\nD::Divisor: Input divisor.\nq::Int: The vertex (1-indexed) from which to start the burn.\nws::Workspace: Any workspace.\n\nReturns\n\nis_superstable::Bool: true if the entire graph was burned.\n\nModifies\n\nws.burned: Tracks burned vertices.\nws.legals: The indices of unburned vertices that form a legal firing.\nws.threats: Tracks threats to unburned vertices.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.dhar-Tuple{ChipFiringGraph, Divisor, Int64}","page":"Reference","title":"ChipFiring.dhar","text":"dhar(G::ChipFiringGraph, D::Divisor, q::Int) -> Tuple{Bool, Vector{Int}}\n\nPerforms a burn starting from a source vertex q to determine if the divisor D is super-stable with respect to q.\n\nArguments\n\nG::ChipFiringGraph: The graph structure.\nD::Divisor: The chip configuration to test.\nq::Int: The vertex (1-indexed) from which to start the burn.\n\nReturns\n\nThe first element is true if the divisor is super-stable, false otherwise.\nThe second element is a vector of unburned vertices. This vector is empty if the divisor is super-stable.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.divisor_rank-Tuple{ChipFiringGraph, Divisor}","page":"Reference","title":"ChipFiring.divisor_rank","text":"divisor_rank(G::ChipFiringGraph, D::Divisor) -> Int\n\nReturns the rank (in the sense of Baker and Norine) of a divisor D. See Divisors and Sandpiles by Corry and Perkinson. This is a convenience wrapper.\n\nArguments\n\nG::ChipFiringGraph: The graph to analyze.\nD::Divisor: The divisor whose rank is to be computed.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.find_negative_vertices!-Tuple{Vector{Int64}, ChipFiringGraph, Divisor, Int64}","page":"Reference","title":"ChipFiring.find_negative_vertices!","text":"find_negative_vertices!(out_vec::Vector{Int}, G::ChipFiringGraph, D::Divisor, q::Int)\n\nFinds all vertices with negative chips (excluding the sink q) and pushes them into the pre-allocated out_vec. This is a non-allocating operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.get_num_edges-Tuple{ChipFiringGraph, Int64, Int64}","page":"Reference","title":"ChipFiring.get_num_edges","text":"get_num_edges(G::ChipFiringGraph, u::Int, v::Int) -> Int\n\nReturns the number of edges (multiplicity) between two vertices u and v.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.has_rank_at_least_r!-Tuple{ChipFiringGraph, Int64, Workspace}","page":"Reference","title":"ChipFiring.has_rank_at_least_r!","text":"has_rank_at_least_r!(G::ChipFiringGraph, r::Int, ws::Workspace) -> Bool\n\nChecks if a divisor ws.d1 has rank at least r.\n\nArguments\n\nG::ChipFiringGraph: The graph structure.\nr::Int: The minimum rank to check for.\nws::Workspace: Workspace containing the divisor in ws.d1.\n\nModifies\n\nws.d2: Modified by q_reduced!\nws.burned: Modified by dhar!\nws.legals: Modified by dhar!\nws.threats: Modified by dhar!\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.has_rank_at_least_r-Tuple{ChipFiringGraph, Divisor, Int64}","page":"Reference","title":"ChipFiring.has_rank_at_least_r","text":"has_rank_at_least_r(G::ChipFiringGraph, D::Divisor, r::Int) -> Bool\n\nChecks if a divisor D has rank at least r.\n\nArguments\n\nG::ChipFiringGraph: The graph to analyze.\nD::Divisor: The divisor to check.\nr::Int: The minimum rank to check for.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.is_effective-Tuple{Divisor}","page":"Reference","title":"ChipFiring.is_effective","text":"is_effective(D::Divisor) -> Bool\n\nChecks if a divisor D is effective, meaning all its chip counts are non-negative.\n\nArguments\n\nD::Divisor: The divisor to check.\n\nReturns\n\nBool: true if D(v) geq 0 for all vertices v, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.is_equivalent-Tuple{ChipFiringGraph, Divisor, Divisor}","page":"Reference","title":"ChipFiring.is_equivalent","text":"is_equivalent(G::ChipFiringGraph, D1::Divisor, D2::Divisor) -> Bool\n\nTests if two divisors are equivalent under chip-firing.\n\nArguments\n\nG::ChipFiringGraph: The graph to analyze.\nD1::Divisor: The first divisor.\nD2::Divisor: The second divisor.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.is_winnable!-Tuple{ChipFiringGraph, Divisor, Workspace}","page":"Reference","title":"ChipFiring.is_winnable!","text":"is_winnable!(G::ChipFiringGraph, D::Divisor, ws::Workspace) -> Bool\n\nChecks if a divisor D is linearly equivalent to an effective divisor using a version of Dhar's burning algorithm.\n\nArguments\n\nG::ChipFiringGraph: The graph structure.\nD::Divisor: The initial chip configuration.\nws::Workspace: Any workspace.\n\nModifies\n\nws.d2: Modified by q_reduced!.\nws.burned: Modified by dhar!.\nws.legals: Modified by dhar!.\nws.threats: Modified by dhar!.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.is_winnable-Tuple{ChipFiringGraph, Divisor}","page":"Reference","title":"ChipFiring.is_winnable","text":"is_winnable(G::ChipFiringGraph, D::Divisor) -> Bool\n\nChecks if a divisor D is linearly equivalent to an effective divisor using a version of Dhar's burning algorithm.\n\nThis is a convenience wrapper that allocates a temporary workspace. For performance-critical code where this function is called repeatedly, use the version that accepts a  Workspace argument.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.laplacian-Tuple{ChipFiringGraph}","page":"Reference","title":"ChipFiring.laplacian","text":"laplacian(G::ChipFiringGraph) -> Matrix{Int}\n\nReturns the discrete Laplacian matrix of G.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.lend!-Tuple{ChipFiringGraph, Divisor, Int64}","page":"Reference","title":"ChipFiring.lend!","text":"lend!(G::ChipFiringGraph, D::Divisor, v::Int)\n\nLends (fires) a single vertex v.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.lend!-Tuple{ChipFiringGraph, Divisor, Vector{Int64}}","page":"Reference","title":"ChipFiring.lend!","text":"lend!(G::ChipFiringGraph, D::Divisor, vertices::Vector{Int})\n\nLends (fires) from each vertex in the provided vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.neighbors-Tuple{ChipFiringGraph, Int64}","page":"Reference","title":"ChipFiring.neighbors","text":"neighbors(G::ChipFiringGraph, v::Int) -> Vector{Int}\n\nReturns a vector containing the indices of the neighbors of vertex v.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.next_composition!-Tuple{Vector{Int64}}","page":"Reference","title":"ChipFiring.next_composition!","text":"next_composition!(v::Vector{Int}) -> Bool\n\nMutates a vector v into the next composition of the integer sum(v), generating them in colexicographical order.\n\nAlgorithm\n\nFind the first non-zero element from the left, v[t]. This is the \"pivot\".\nIf no such element exists (or it's the last one), we are at the end of the sequence.\nMove one unit from the pivot to its right neighbor: v[t+1] += 1.\nMove the remaining value of the pivot (v[t] - 1) to the very first position v[1].\nSet the pivot's original position v[t] to zero.\n\nExample: [3, 0, 0] -> [2, 1, 0] -> [1, 2, 0] -> [0, 3, 0] -> [2, 0, 1] ...\n\nReturns\n\ntrue if a next configuration was generated.\nfalse if v was already the last configuration (e.g., [0, 0, ..., d]).\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.parse_graph6-Tuple{String}","page":"Reference","title":"ChipFiring.parse_graph6","text":"parse_graph6(g6_string::String) -> ChipFiringGraph\n\nParses a graph from a string in the graph6 format and returns a ChipFiringGraph.\n\nThis function fully implements the graph6 specification for simple, undirected graphs, including the 1, 4, and 8-byte encodings for the number of vertices.\n\nArguments\n\ng6_string::String: The string representing the graph. An optional header >>graph6<< is ignored if present.\n\nReturns\n\nA ChipFiringGraph object.\n\nThrows\n\nArgumentError: If the string is malformed, contains invalid characters, or ends unexpectedly.\n\nWARNING:\n\nThe backslash `` is a valid character in the graph6 format, but needs to be escaped in Julia.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.q_reduced!-Tuple{ChipFiringGraph, Divisor, Int64, Workspace}","page":"Reference","title":"ChipFiring.q_reduced!","text":"q_reduced!(G::ChipFiringGraph, D::Divisor, q::Int, ws::Workspace) -> Divisor\n\nFinds the equivalent q-reduced effective divisor to D.\n\nArguments\n\nG::ChipFiringGraph: The graph structure.\nD::Divisor: The initial chip configuration.\nq::Int: The sink vertex.\nws::Workspace: Any workspace.\n\nReturns\n\nd::Divisor: The resulting divisor\n\nModifies\n\nws.d2: Uses this space to construct the resulting divisor\nws.burned: Modified by dhar!.\nws.legals: Modified by dhar!.\nws.threats: Modified by dhar!.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.q_reduced-Tuple{ChipFiringGraph, Divisor, Int64}","page":"Reference","title":"ChipFiring.q_reduced","text":"q_reduced(G::ChipFiringGraph, D::Divisor, q::Int) -> Divisor\n\nFinds the equivalent q-reduced effective divisor to D.\n\nThis is a convenience wrapper that allocates a temporary workspace. For performance-critical code where this function is called repeatedly, use the version that accepts a  Workspace argument.\n\nArguments\n\nG::ChipFiringGraph: The graph structure.\nD::Divisor: The initial chip configuration.\nq::Int: The sink vertex.\n\nReturns\n\nd::Divisor: The resulting divisor\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.subdivide-Tuple{ChipFiringGraph, Int64}","page":"Reference","title":"ChipFiring.subdivide","text":"subdivide(G::ChipFiringGraph, k::Int) -> ChipFiringGraph\n\nGiven a ChipFiringGraph G, produces another ChipFiringGraph which is an k-uniform subdivision of G.\n\nArguments\n\nG::ChipFiringGraph: The original graph\nk::Int: Number of uniform subdivisions (e.g., 1 returns original graph, 2 produces 2-uniform subdivision)\n\nReturns\n\nA k-uniform subdivided ChipFiringGraph\n\n\n\n\n\n","category":"method"},{"location":"bg/#Background-and-conventions","page":"Background and conventions","title":"Background and conventions","text":"","category":"section"},{"location":"bg/#Graphs-and-divisors","page":"Background and conventions","title":"Graphs and divisors","text":"","category":"section"},{"location":"bg/","page":"Background and conventions","title":"Background and conventions","text":"We take a graph to be with multi-edges, connected, and no self-loops. We label the vertices 1 dots n. The valence of a vertex v is the number of edges incident to v.","category":"page"},{"location":"bg/","page":"Background and conventions","title":"Background and conventions","text":"A ChipFiringGraph encodes the graph structure. It can be constructed through either a multiplicity matrix or an edge list.","category":"page"},{"location":"bg/","page":"Background and conventions","title":"Background and conventions","text":"For example:","category":"page"},{"location":"bg/","page":"Background and conventions","title":"Background and conventions","text":"julia> multiplicity_matrix = [\n    0 2 0 1;\n    2 0 1 0;\n    0 1 0 1;\n    1 0 1 0   \n]\n[output omitted]\n\njulia> edge_list = [(1,2), (1,2), (1,4), (2,3), (3,4)]\n[output omitted]\n\n# Constructor: multiplicity matrix\njulia> g = ChipFiringGraph(multiplicity_matrix)\nGraph(V=4, E=5, Edges=[(1, 2), (1, 2), (1, 4), (2, 3), (3, 4)])\n\n# Constructor: number of vertices and edge list\njulia> g = ChipFiringGraph(4, edge_list)","category":"page"},{"location":"bg/","page":"Background and conventions","title":"Background and conventions","text":"A Divisor encodes a divisor on a graph. However, it is a distinct object from a ChipFiringGraph  and for all practical purposes, it will act like a vector, where the i-th index corresponds to the number of chips on vertex i.","category":"page"},{"location":"bg/","page":"Background and conventions","title":"Background and conventions","text":"julia> d = Divisor([1, 2, 3, -1])\n4-element Divisor:\n  1\n  2\n  3\n -1","category":"page"},{"location":"performance/#Performance-tips","page":"Performance tips","title":"Performance tips","text":"","category":"section"},{"location":"performance/","page":"Performance tips","title":"Performance tips","text":"ChipFiring.jl is a package intended for performance-sensitive applications. Below are some tips on using the package if users are interested in performance.","category":"page"},{"location":"performance/#Workspace","page":"Performance tips","title":"Workspace","text":"","category":"section"},{"location":"performance/","page":"Performance tips","title":"Performance tips","text":"A key design pattern in this package is the Workspace environment, a structure that pre-allocates memory for divisors and vertex sets. Most users won't need to interact with this directly, as all functions that use a Workspace also have a convenient wrapper function. However, for performance-critical applications involving many calls to low-level operations (e.g., dhar, q_reduced), you should use the Workspace counterparts (e.g., dhar! and q_reduced!). Typically, just passing any Workspace will work, but there are some instances where a certain field of a Workspace is read as input to a function.","category":"page"},{"location":"performance/#Multi-threading","page":"Performance tips","title":"Multi-threading","text":"","category":"section"},{"location":"performance/","page":"Performance tips","title":"Performance tips","text":"If you're processing many graphs on a multi-core CPU, you can parallelize the work using Julia's @threads macro. For gonality computations, the workloads tend to be very unbalanced, so it's best to use the :greedy scheduler to prevent threads from remaining idle. This option is available in Julia v1.11+. An example is below:","category":"page"},{"location":"performance/","page":"Performance tips","title":"Performance tips","text":"@threads :greedy for i in 1:num_graphs\n        println(compute_gonality(graphs_to_process[i]))\nend","category":"page"},{"location":"performance/","page":"Performance tips","title":"Performance tips","text":"Crucially, you cannot share a single Workspace between multiple threads.","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Below are some self-contained examples of the code in ChipFiring.jl.","category":"page"},{"location":"examples/#1-Graph-construction","page":"Examples","title":"1 Graph construction","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using ChipFiring\n# Construction of a house graph with an extra edge\n#\n#      (5)\n#     /   \\\n#    /     \\\n#  (3)-----(4)\n#   |       |\n#   |       |\n#  (1)=====(2)\n#\nmultiplicity_matrix = [\n    0 2 1 0 0;\n    2 0 0 1 0;\n    1 0 0 1 1;\n    0 1 1 0 1;\n    0 0 1 1 0\n]\n\n# Construction of a `ChipFiringGraph` via multiplicity matrix\ng1 = ChipFiringGraph(multiplicity_matrix)\n\nnum_vertices = 5\nedge_list = [(1, 2), (1, 2), (1, 3), (2, 4), (3, 4), (3, 5), (4, 5)]\n\n# Construction of a `ChipFiringGraph` via edge list\ng2 = ChipFiringGraph(num_vertices, edge_list)","category":"page"},{"location":"examples/#2-Compute-graph-gonality","page":"Examples","title":"2 Compute graph gonality","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using ChipFiring\n\nicosahedron_adj_matrix =[\n    0 1 1 1 1 0 0 0 1 0 0 0;\n    1 0 1 0 1 1 1 0 0 0 0 0;\n    1 1 0 0 0 0 1 1 1 0 0 0;\n    1 0 0 0 1 0 0 0 1 1 1 0;\n    1 1 0 1 0 1 0 0 0 1 0 0;\n    0 1 0 0 1 0 1 0 0 1 0 1;\n    0 1 1 0 0 1 0 1 0 0 0 1;\n    0 0 1 0 0 0 1 0 1 0 1 1;\n    1 0 1 1 0 0 0 1 0 0 1 0;\n    0 0 0 1 1 1 0 0 0 0 1 1;\n    0 0 0 1 0 0 0 1 1 1 0 1;\n    0 0 0 0 0 1 1 1 0 1 1 0\n]\n\ng = ChipFiringGraph(icosahedron_adj_matrix)\n\n# Compute the gonality of an icosahedron to be 9\ncompute_gonality(g)\n\n# We can also specify ranks for `compute_gonality` to compute\ncompute_gonality(g, min_d=7, max_d=10)\n\n# If the function finds that the gonality is greater than `max_d`, then it will return `-1`\ncompute_gonality(g, min_d=6, max_d=8)\n\n# Verbose mode that prints a winning divisor.\ncompute_gonality(g, verbose=true)\n","category":"page"},{"location":"examples/#3-Uniform-subdivision-of-graphs","page":"Examples","title":"3 Uniform subdivision of graphs","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"using ChipFiring\n\ntricycle_mult_matrix =[\n    0 1 1 1 1 1 1;\n    1 0 1 0 0 0 2;\n    1 1 0 2 0 0 0;\n    1 0 2 0 1 0 0;\n    1 0 0 1 0 2 0;\n    1 0 0 0 2 0 1;\n    1 2 0 0 0 1 0;\n]\n\ng = ChipFiringGraph(tricycle_mult_matrix)\n\n# The gonality of the tricycle graph is 6 (https://arxiv.org/pdf/2106.12568)\ncompute_gonality(g)\n\n# Create a 2-uniform subdivision of the tricycle graph\ng_subdivided = subdivide(g, 2)\n\n# The gonality of the subdivided tricycle graph is 5\ncompute_gonality(g_subdivided)","category":"page"},{"location":"#ChipFiring.jl","page":"Home","title":"ChipFiring.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ChipFiring.jl is a Julia package for analyzing chip-firing games on graphs. The codes are roughly based on the algorithms given in Sandpiles and Divisors: An Introduction to Chip-Firing by Corry and Perkinson (2018). A key objective is for the package to be useful for both researchers and students. Its features include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Basic operations on chip-firing graphs (e.g. firing, lending)\n(Thread-safe) computations of r-th graph gonality\nUniform subdivisions of graphs\nRank computations\nq-reduction, Dhar's burning algorithm, and equivalence\nConversion from graph6 format","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have not installed Julia, please follow the instructions here. ChipFiring.jl works with Julia v1.10 and newer, but the latest stable release is recommended.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ChipFiring.jl is a registered Julia package. The following commands in the Julia REPL will install ChipFiring.jl. You may copy and paste these commands into REPL including the leading julia> prompts – they will automatically be trimmed by Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\n\njulia> Pkg.add(\"ChipFiring\")","category":"page"},{"location":"#A-short-example","page":"Home","title":"A short example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package must first be loaded.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using ChipFiring","category":"page"},{"location":"","page":"Home","title":"Home","text":"Below, we calcuate the gonality of a graph, as well as q-reduce a divisor on the graph.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> multiplicity_matrix = [\n    0 2 0 1;\n    2 0 1 0;\n    0 1 0 1;\n    1 0 1 0   \n]\n[output omitted]\n\njulia> g = ChipFiringGraph(multiplicity_matrix)\nGraph(V=4, E=5, Edges=[(1, 2), (1, 2), (1, 4), (2, 3), (3, 4)])\n\njulia> compute_gonality(g)\n2\n\njulia> d = Divisor([1, 1, 1, 1])\nDivisor([1, 1, 1, 1])\n\njulia> q_reduced(g, d, 1)\nDivisor([-4, 1, 1, 0])","category":"page"},{"location":"","page":"Home","title":"Home","text":"More examples can be found in the docs.","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package was developed during the SMALL 2025 REU hosted at Williams College, funded by NSF Grant DMS2241623. Special thanks to Charlotte Chen, Benham Cobb, Ralph Morrison, Noam Pasman, Madeline Reeve, for contributing code and/or feedback.","category":"page"}]
}
