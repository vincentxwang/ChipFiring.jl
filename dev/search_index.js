var documenterSearchIndex = {"docs":
[{"location":"api/#ChipFiring","page":"Reference","title":"ChipFiring","text":"","category":"section"},{"location":"api/","page":"Reference","title":"Reference","text":"Documentation for ChipFiring.","category":"page"},{"location":"api/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"api/#ChipFiring.ChipFiringGraph","page":"Reference","title":"ChipFiring.ChipFiringGraph","text":"ChipFiringGraph\n\nA structure to represent the underlying graph of a chip-firing graph.\n\nThis struct provides multiple representations of the graph's structure to suit different computational needs. It is designed for undirected, connected graphs, and the input multiplicity matrix is expected to be symmetric.\n\nFields\n\nadj_matrix::Matrix{Int}: The n x n multiplicity matrix, where adj_matrix[i, j] is the number of edges between vertex i and vertex j.\nnum_vertices::Int: The number of vertices in the graph, n.\nnum_edges::Int: The total number of edges in the graph.\nadj_list::Vector{Vector{Int}}: An adjacency list where adj_list[i] contains the neighbors of vertex i. This represents the underlying simple graph, meaning each neighbor appears only once, regardless of edge multiplicity.\nedge_list::Vector{Tuple{Int, Int}}: A vector of tuples, where each tuple (i, j) represents an edge. Edges are included with their full multiplicity.\nvalency_list::Vector{Int}: A vector where valency_list[i] stores the degree of vertex i, accounting for edge multiplicity.\n\nConstructors\n\nChipFiringGraph(multiplicity_matrix::Matrix{Int}): Constructs a ChipFiringGraph from a square, symmetric multiplicity matrix. Throws an error if the matrix is not square, not symmetric, or if the graph is not connected.\nChipFiringGraph(num_vertices::Int, edge_list::Vector{Tuple{Int, Int}}): Constructs a ChipFiringGraph from a list of edges and the total number of vertices.\n\n\n\n\n\n","category":"type"},{"location":"api/#ChipFiring.Divisor","page":"Reference","title":"ChipFiring.Divisor","text":"Divisor <: AbstractVector{Int}\n\nA struct representing a chip configuration (or \"divisor\") on a graph.\n\nFields\n\nchips::Vector{Int}: An n-element vector where chips[i] is the number of chips on vertex i.\n\n\n\n\n\n","category":"type"},{"location":"api/#ChipFiring.Workspace","page":"Reference","title":"ChipFiring.Workspace","text":"Workspace\n\nA mutable container for pre-allocated arrays and temporary data structures used in performance-critical algorithms.\n\nThis struct is exposed for users who need to run many computations in a tight loop and want to avoid repeated memory allocations. For one-off calculations, it is often more convenient to use the wrapper functions (e.g., q_reduced(g, d, q)) which handle workspace creation automatically.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.getindex-Tuple{Divisor, Int64}","page":"Reference","title":"Base.getindex","text":"getindex(d::Divisor, i::Int)\n\nReturns the number of chips on vertex i. Allows d[i] syntax.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.setindex!-Tuple{Divisor, Any, Int64}","page":"Reference","title":"Base.setindex!","text":"setindex!(d::Divisor, val, i::Int)\n\nSets the number of chips on vertex i. Allows d[i] = val syntax.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.show-Tuple{IO, ChipFiringGraph}","page":"Reference","title":"Base.show","text":"show(io::IO, g::ChipFiringGraph)\n\nProvides a concise, single-line string representation of a ChipFiringGraph. To obtain a string output, the string() function can do so.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.size-Tuple{Divisor}","page":"Reference","title":"Base.size","text":"size(d::Divisor)\n\nReturns the size of the divisor (the number of vertices).\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.borrow!-Tuple{ChipFiringGraph, Divisor, Int64}","page":"Reference","title":"ChipFiring.borrow!","text":"borrow!(g::ChipFiringGraph, d::Divisor, v::Int)\n\nBorrows from a single vertex v.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.borrow!-Tuple{ChipFiringGraph, Divisor, Vector{Int64}}","page":"Reference","title":"ChipFiring.borrow!","text":"borrow!(g::ChipFiringGraph, d::Divisor, vertices::Vector{Int})\n\nBorrows from each vertex in the provided vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.clear!-Tuple{Workspace}","page":"Reference","title":"ChipFiring.clear!","text":"clear!(ws::Workspace)\n\nResets all fields in the Workspace to their default initial states.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.compute_genus-Tuple{ChipFiringGraph}","page":"Reference","title":"ChipFiring.compute_genus","text":"compute_genus(g::ChipFiringGraph) -> Int\n\nReturns the genus (in the topological sense) of the graph represented by g. Note that this is  not the typical definition of graph genus.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.compute_gonality-Tuple{ChipFiringGraph}","page":"Reference","title":"ChipFiring.compute_gonality","text":"compute_gonality(g::ChipFiringGraph; min_d=1, max_d=nothing, verbose=false, r=1) -> Int\n\nComputes the r-th (default: 1) gonality of a graph g.\n\nArguments\n\ng::ChipFiringGraph: The graph to analyze.\n\nOptional Arguments\n\nmin_d=1: The minimum degree d to check.\nmax_d=nothing: The maximum degree d to check. Defaults to nothing.\nverbose=false:  If true, prints progress updates.\nr=1: Calculates r-th gonality. Defaults to 1.\n\nReturns\n\nInt: The computed gonality of the graph. Returns -1 if not found within max_d.\n\nThe result of computegonality may return r * n in the case when maxd is set to r * n - 1.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.dhar!-Tuple{ChipFiringGraph, Divisor, Int64, Workspace}","page":"Reference","title":"ChipFiring.dhar!","text":"dhar!(g::ChipFiringGraph, divisor::Divisor, source::Int, ws::Workspace) -> Bool\n\nPerforms a recursive burn starting from a source vertex to determine if a divisor is super-stable with respect to that source.\n\nFollowing the user's definition, a divisor is super-stable if the entire graph burns. A vertex v \"burns\" if its number of chips is less than the number of edges connecting it to already-burnt vertices.\n\nArguments\n\ng::ChipFiringGraph: The graph structure.\ndivisor::Divisor: Input divisor.\nsource::Int: The vertex (1-indexed) from which to start the burn.\nws::Workspace: The following fields are read from ws: ws.burned, ws.legals, ws.threats\n\nReturns\n\nis_superstable::Bool: true if the entire graph was burned.\n\nModifies\n\nws.burned::Vector{Bool}: Tracks burned vertices. \nws.legals::Vector{Int}: The indices of unburned vertices that form a legal firing.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.dhar-Tuple{ChipFiringGraph, Divisor, Int64}","page":"Reference","title":"ChipFiring.dhar","text":"dhar(g::ChipFiringGraph, divisor::Divisor, source::Int) -> Tuple{Bool, Vector{Int}}\n\nPerforms a burn starting from a source vertex to determine if a divisor is super-stable.\n\nThis is a convenience wrapper that allocates a temporary workspace. For performance-critical code where this function is called repeatedly, use the version that accepts a  Workspace argument.\n\nArguments\n\ng::ChipFiringGraph: The graph structure.\ndivisor::Divisor: The chip configuration to test.\nsource::Int: The vertex (1-indexed) from which to start the burn.\n\nReturns\n\nThe first element is true if the divisor is super-stable, false otherwise.\nThe second element is a vector of unburned vertices. This vector is empty if the divisor is super-stable.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.divisor_rank-Tuple{ChipFiringGraph, Divisor}","page":"Reference","title":"ChipFiring.divisor_rank","text":"divisor_rank(g::ChipFiringGraph, d::Divisor) -> Int\n\nGiven a ChipFiringGraph g and Divisor d, returns the rank (in the sense of Baker and Norine) of d on g. See Divisors and Sandpiles by Corry and Perkinson. This is a convenience wrapper.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.find_negative_vertices!-Tuple{Vector{Int64}, ChipFiringGraph, Divisor, Int64}","page":"Reference","title":"ChipFiring.find_negative_vertices!","text":"find_negative_vertices!(out_vec::Vector{Int}, g::ChipFiringGraph, d::Divisor, q::Int)\n\nFinds all vertices with negative chips (excluding the sink q) and pushes them into the pre-allocated out_vec. This is a non-allocating operation.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.get_num_edges-Tuple{ChipFiringGraph, Int64, Int64}","page":"Reference","title":"ChipFiring.get_num_edges","text":"get_num_edges(g::ChipFiringGraph, u::Int, v::Int) -> Int\n\nReturns the number of edges (multiplicity) between two vertices u and v.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.has_rank_at_least_r!-Tuple{ChipFiringGraph, Int64, Workspace}","page":"Reference","title":"ChipFiring.has_rank_at_least_r!","text":"has_rank_at_least_r!(g::ChipFiringGraph, r::Int, ws::Workspace) -> Bool\n\nChecks if a divisor ws.d1 has rank at least r.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.has_rank_at_least_r-Tuple{ChipFiringGraph, Divisor, Int64}","page":"Reference","title":"ChipFiring.has_rank_at_least_r","text":"has_rank_at_least_r(g::ChipFiringGraph, d::Divisor, r::Int) -> Bool\n\nGiven a ChipFiringGraph g and Divisor d, returns a boolean determining whether or not d has rank at least r. \n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.is_effective-Tuple{Divisor}","page":"Reference","title":"ChipFiring.is_effective","text":"is_effective(d::Divisor) -> Bool\n\nChecks if a divisor is effective, meaning all its chip counts are non-negative.\n\nArguments\n\nd::Divisor: The divisor to check.\n\nReturns\n\nBool: true if d[v] >= 0 for all vertices v, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.is_equivalent-Tuple{ChipFiringGraph, Divisor, Divisor}","page":"Reference","title":"ChipFiring.is_equivalent","text":"is_equivalent(g::ChipFiringGraph, d1::Divisor, d2::Divisor) -> Bool\n\nTests if two divisors are equivalent under chip-firing.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.is_winnable!-Tuple{ChipFiringGraph, Divisor, Workspace}","page":"Reference","title":"ChipFiring.is_winnable!","text":"is_winnable(g::ChipFiringGraph, divisor::Divisor, ws::Workspace) -> Bool\n\nChecks if a chip configuration is linearly equivalent to an effective divisor using a version of Dhar's burning algorithm.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.is_winnable-Tuple{ChipFiringGraph, Divisor}","page":"Reference","title":"ChipFiring.is_winnable","text":"is_winnable(g::ChipFiringGraph, divisor::Divisor) -> Bool\n\nChecks if a chip configuration is linearly equivalent to an effective divisor using a version of Dhar's burning algorithm.\n\nThis is a convenience wrapper that allocates a temporary workspace. For performance-critical code where this function is called repeatedly, use the version that accepts a  Workspace argument.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.laplacian-Tuple{ChipFiringGraph}","page":"Reference","title":"ChipFiring.laplacian","text":"laplacian(g::ChipFiringGraph) -> Matrix{Int}\n\nReturns the discrete Laplacian matrix of g.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.lend!-Tuple{ChipFiringGraph, Divisor, Int64}","page":"Reference","title":"ChipFiring.lend!","text":"lend!(g::ChipFiringGraph, d::Divisor, v::Int)\n\nLends (fires) a single vertex v.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.lend!-Tuple{ChipFiringGraph, Divisor, Vector{Int64}}","page":"Reference","title":"ChipFiring.lend!","text":"lend!(g::ChipFiringGraph, d::Divisor, vertices::Vector{Int})\n\nLends (fires) from each vertex in the provided vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.neighbors-Tuple{ChipFiringGraph, Int64}","page":"Reference","title":"ChipFiring.neighbors","text":"neighbors(g::ChipFiringGraph, v::Int) -> Vector{Int}\n\nReturns a vector containing the indices of the neighbors of vertex v.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.next_composition!-Tuple{Vector{Int64}}","page":"Reference","title":"ChipFiring.next_composition!","text":"next_composition!(v::Vector{Int}) -> Bool\n\nMutates a vector v into the next composition of the integer sum(v), generating them in colexicographical order.\n\nAlgorithm\n\nFind the first non-zero element from the left, v[t]. This is the \"pivot\".\nIf no such element exists (or it's the last one), we are at the end of the sequence.\nMove one unit from the pivot to its right neighbor: v[t+1] += 1.\nMove the remaining value of the pivot (v[t] - 1) to the very first position v[1].\nSet the pivot's original position v[t] to zero.\n\nExample: [3, 0, 0] -> [2, 1, 0] -> [1, 2, 0] -> [0, 3, 0] -> [2, 0, 1] ...\n\nReturns\n\ntrue if a next configuration was generated.\nfalse if v was already the last configuration (e.g., [0, 0, ..., d]).\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.parse_graph6-Tuple{String}","page":"Reference","title":"ChipFiring.parse_graph6","text":"parse_graph6(g6_string::String) -> ChipFiringGraph\n\nParses a graph from a string in the graph6 format and returns a ChipFiringGraph.\n\nThis function fully implements the graph6 specification for simple, undirected graphs, including the 1, 4, and 8-byte encodings for the number of vertices.\n\nArguments\n\ng6_string::String: The string representing the graph. An optional header >>graph6<< is ignored if present.\n\nReturns\n\nA ChipFiringGraph object.\n\nThrows\n\nArgumentError: If the string is malformed, contains invalid characters, or ends unexpectedly.\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.q_reduced!-Tuple{ChipFiringGraph, Divisor, Int64, Workspace}","page":"Reference","title":"ChipFiring.q_reduced!","text":"q_reduced!(g::ChipFiringGraph, divisor::Divisor; q::Int, ws::Workspace) -> Divisor\n\nFinds the equivalent, q-reduced effective divisor to the one given.\n\nArguments\n\ng: The graph structure.\ndivisor: The initial chip configuration.\nq: The sink vertex.\nws: The workspace containing pre-allocated arrays.\n\nReturns\n\nd::Divisor: The resulting divisor\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.q_reduced-Tuple{ChipFiringGraph, Divisor, Int64}","page":"Reference","title":"ChipFiring.q_reduced","text":"q_reduced(g::ChipFiringGraph, divisor::Divisor; q::Int, ws::Workspace) -> Divisor\n\nFinds the equivalent, q-reduced effective divisor to the one given, based on the algorithm from the user-provided Python code.\n\nThis is a convenience wrapper that allocates a temporary workspace. For performance-critical code where this function is called repeatedly, use the version that accepts a  Workspace argument.\n\nArguments\n\ng: The graph structure.\ndivisor: The initial chip configuration.\nq: The sink vertex.\nws: The workspace containing pre-allocated arrays.\n\nReturns\n\nd::Divisor: The resulting divisor\n\n\n\n\n\n","category":"method"},{"location":"api/#ChipFiring.subdivide-Tuple{ChipFiringGraph, Int64}","page":"Reference","title":"ChipFiring.subdivide","text":"subdivide(g::ChipFiringGraph, subdivisions::Int) -> ChipFiringGraph\n\nGiven a ChipFiringGraph g, produces another ChipFiringGraph which is an k-uniform subdivision of g.\n\nArguments\n\ng::ChipFiringGraph the original graph\nsubdivisions::Int number of uniform subdivisions (1 returns original graph, 2 produces 2-uniform subdivision, etc.)\n\nReturns\n\nA k-uniform subdivided ChipFiringGraph\n\n\n\n\n\n","category":"method"},{"location":"bg/#Background-and-conventions","page":"Background and conventions","title":"Background and conventions","text":"","category":"section"},{"location":"bg/","page":"Background and conventions","title":"Background and conventions","text":"We take a graph to be with multi-edges, connected, and no self-loops. We label the vertices 1 dots n. The valence of a vertex v is the number of edges incident to v.","category":"page"},{"location":"bg/","page":"Background and conventions","title":"Background and conventions","text":"A ChipFiringGraph encodes the graph structure. It can be constructed through either a multiplicity matrix or an edge list.","category":"page"},{"location":"bg/","page":"Background and conventions","title":"Background and conventions","text":"For example:","category":"page"},{"location":"bg/","page":"Background and conventions","title":"Background and conventions","text":"julia> multiplicity_matrix = [\n    0 2 0 1;\n    2 0 1 0;\n    0 1 0 1;\n    1 0 1 0   \n]\n[output omitted]\n\njulia> edge_list = [(1,2), (1,2), (1,4), (2,3), (3,4)]\n[output omitted]\n\n# Constructor: multiplicity matrix\njulia> g = ChipFiringGraph(multiplicity_matrix)\nGraph(V=4, E=5, Edges=[(1, 2), (1, 2), (1, 4), (2, 3), (3, 4)])\n\n# Constructor: number of vertices and edge list\njulia> g = ChipFiringGraph(4, edge_list)","category":"page"},{"location":"bg/","page":"Background and conventions","title":"Background and conventions","text":"A Divisor encodes a divisor on a graph. However, it is a distinct object from a ChipFiringGraph  and for all practical purposes, it will act like a vector, where the i-th index corresponds to the number of chips on vertex i.","category":"page"},{"location":"bg/","page":"Background and conventions","title":"Background and conventions","text":"julia> d = Divisor([1, 2, 3, -1])\n4-element Divisor:\n  1\n  2\n  3\n -1","category":"page"},{"location":"#ChipFiring.jl","page":"Home","title":"ChipFiring.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ChipFiring.jl is a Julia package for analyzing chip-firing games on graphs. The codes are roughly based on the algorithms given in Sandpiles and Divisors: An Introduction to Chip-Firing by Corry and Perkinson (2018). A key objective is for the package to be useful for both researchers and students. The package is built around a two-tier API design: a simple layer for interactive use, and a high-performance layer for intensive computations. Its features include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Basic operations on chip-firing graphs (e.g. firing, lending)\nComputations of r-th graph gonality\nUniform subdivisions of graphs\nRank computations\nq-reduction, Dhar's burning algorithm, and equivalence\nConversion from graph6 format","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have not installed Julia, please follow the instructions here. ChipFiring.jl works with Julia v1.10 and newer, but the latest stable release is recommended.","category":"page"},{"location":"","page":"Home","title":"Home","text":"ChipFiring.jl is a registered Julia package. The following commands in the Julia REPL will install ChipFiring.jl. You may copy and paste these commands into REPL including the leading julia> prompts – they will automatically be trimmed by Julia.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\n\njulia> Pkg.add(\"ChipFiring\")","category":"page"},{"location":"#A-short-example","page":"Home","title":"A short example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package must first be loaded.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using ChipFiring","category":"page"},{"location":"","page":"Home","title":"Home","text":"Below, we calcuate the gonality of a graph, as well as q-reduce a divisor on the graph.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> multiplicity_matrix = [\n    0 2 0 1;\n    2 0 1 0;\n    0 1 0 1;\n    1 0 1 0   \n]\n[output omitted]\n\njulia> g = ChipFiringGraph(multiplicity_matrix)\nGraph(V=4, E=5, Edges=[(1, 2), (1, 2), (1, 4), (2, 3), (3, 4)])\n\njulia> compute_gonality(g)\n2\n\njulia> d = Divisor([1, 1, 1, 1])\nDivisor([1, 1, 1, 1])\n\njulia> q_reduced(g, d, 1)\nDivisor([-4, 1, 1, 0])","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package was developed during the SMALL 2025 REU hosted at Williams College, funded by NSF Grant DMS2241623. Special thanks to Charlotte Chen, Benham Cobb, Ralph Morrison, Noam Pasman, Madeline Reeve, for contributing code and/or feedback.","category":"page"}]
}
